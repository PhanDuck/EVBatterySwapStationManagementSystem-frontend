// import React, { useEffect, useMemo, useState } from "react";
// import NavBar from "../../components/navbar/navBar";
// import Map, { Marker, Popup, Source, Layer } from "react-map-gl/maplibre";
// import "maplibre-gl/dist/maplibre-gl.css";
// import api from "../../config/axios";
// import NearestStation from "../../components/Shared/NearestStation";

// const MAPTILER_STYLE_URL = `https://api.maptiler.com/maps/streets/style.json?key=CLD54Ny17919txndKdiP`;
// const containerStyle = {
//   width: "100%",
//   height: "70vh",
//   borderRadius: 12,
//   overflow: "hidden",
//   boxShadow: "0 10px 30px rgba(0,0,0,0.08)",
// };
// // T·ªça ƒë·ªô g·ªëc (Home/Base - FPT)
// const FPT_SAIGON = { lat: 10.841127, lng: 106.809866 };
// const ORS_API_KEY =
//   "eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImY1MTNiMzM0OTdhZDQ0Mjk5OGI2MWZjMzU1MzJmYmRhIiwiaCI6Im11cm11cjY0In0=";

// // ƒê·ªãnh nghƒ©a Style cho Polyline (ƒê∆∞·ªùng ƒëi)
// const polylineLayerStyle = {
//   id: "route-line",
//   type: "line",
//   paint: {
//     "line-color": "#2563eb",
//     "line-width": 5,
//     "line-opacity": 0.85,
//   },
// };

// const PinMarker = ({ color, capacity = null, isOrigin = false }) => {
//   const size = isOrigin ? 20 : 28;

//   return (
//     <div
//       style={{
//         position: "relative",
//         display: "flex",
//         flexDirection: "column",
//         alignItems: "center",
//         cursor: "pointer",
//       }}
//     >
//       {/* Th√¢n Marker (H√¨nh tr√≤n/elip) */}
//       <div
//         style={{
//           width: size,
//           height: size,
//           borderRadius: "50% 50% 50% 0", // T·∫°o h√¨nh d·∫°ng gi·ªçt n∆∞·ªõc ƒë∆°n gi·∫£n
//           backgroundColor: color,
//           boxShadow: "0 0 5px rgba(0,0,0,0.3)",
//           transform: "rotate(-45deg)", // Xoay ƒë·ªÉ t·∫°o h√¨nh m≈©i nh·ªçn h∆∞·ªõng xu·ªëng
//           border: "1px solid #fff",
//           display: "flex",
//           alignItems: "center",
//           justifyContent: "center",
//           marginBottom: -3, // K√©o l√™n ƒë·ªÉ ph·∫ßn m≈©i nh·ªçn ch·∫°m ƒë√∫ng t·ªça ƒë·ªô
//         }}
//       >
//         {/* Text ho·∫∑c icon b√™n trong */}
//         {capacity && (
//           <span
//             style={{
//               transform: "rotate(45deg)", // Xoay ng∆∞·ª£c l·∫°i ƒë·ªÉ text th·∫≥ng
//               color: "white",
//               fontWeight: 700,
//               fontSize: isOrigin ? 12 : 10,
//             }}
//           >
//             {capacity}
//           </span>
//         )}
//       </div>
//     </div>
//   );
// };

// // =========================================================================
// // H√ÄM FORMAT V√Ä X·ª¨ L√ù T·ªåA ƒê·ªò
// // =========================================================================
// const formatDuration = (seconds) => {
//   const h = Math.floor(seconds / 3600);
//   const m = Math.floor((seconds % 3600) / 60);
//   return `${h > 0 ? h + " gi·ªù " : ""}${m} ph√∫t`;
// };

// const formatDistance = (meters) => {
//   if (meters < 1000) return `${Math.round(meters)} m`;
//   return `${(meters / 1000).toFixed(1)} km`;
// };

// const parseCoordinate = (text) => {
//   const parts = text.split(",").map((p) => parseFloat(p.trim()));
//   if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
//     // Gi·∫£ ƒë·ªãnh ng∆∞·ªùi d√πng nh·∫≠p (lat, lng)
//     return { lat: parts[0], lng: parts[1] };
//   }
//   return null;
// };

// // COMPONENT CH√çNH

// function StationsNearbyPage() {
//   // using FPT_SAIGON directly as default center

//   // 1. STATE D·ªÆ LI·ªÜU
//   const [stations, setStations] = useState([]);
//   const [isLoading, setIsLoading] = useState(true);
//   const [error, setError] = useState(null);

//   // 2. STATE ROUTING
//   const [selectedStationName, setSelectedStationName] = useState("");
//   const [currentOrigin, setCurrentOrigin] = useState(); // Th√™m state Origin
//   const [originText] = useState(""); // read-only origin text for now

//   const [routeGeoJSON, setRouteGeoJSON] = useState(null);
//   const [routeLoading, setRouteLoading] = useState(false);
//   const [routeInfo, setRouteInfo] = useState(null);
//   const [routeError, setRouteError] = useState(null);

//   // 3. STATE VIEWPORT/MAP
//   const [viewState, setViewState] = useState({
//     longitude: FPT_SAIGON.lng,
//     latitude: FPT_SAIGON.lat,
//     zoom: 12,
//   });

//   // 4. STATE POPUP
//   const [popupInfo, setPopupInfo] = useState(null);

//   const currentStation = useMemo(
//     () => stations.find((s) => s.name === selectedStationName) || null,
//     [selectedStationName, stations]
//   );

//   // =========================================================================
//   // H√ÄM L·∫§Y V·ªä TR√ç NG∆Ø·ªúI D√ôNG (N·∫æU C·∫¶N)
//   // =========================================================================
//   const [userLocation, setUserLocation] = useState(null); // { latitude, longitude }
//   const getUserLocation = () => {
//     // if geolocation is supported by the users browser
//     if (navigator.geolocation) {
//       // get the current users location
//       navigator.geolocation.getCurrentPosition(
//         (position) => {
//           // save the geolocation coordinates in two variables
//           const { latitude, longitude } = position.coords;
//           // update the value of userlocation variable ‚Äî store both shapes to be safe
//           setUserLocation({
//             latitude,
//             longitude,
//             lat: latitude,
//             lng: longitude,
//           });
//           setCurrentOrigin({ lat: latitude, lng: longitude });
//         },
//         // if there was an error getting the users location
//         (error) => {
//           console.error("Error getting user location:", error);
//         }
//       );
//     }
//     // if geolocation is not supported by the users browser
//     else {
//       console.error("Geolocation is not supported by this browser.");
//     }
//   };

//   // =========================================================================
//   // H√ÄM G·ªåI API TR·∫†M (Logic x·ª≠ l√Ω t·ªça ƒë·ªô ƒë∆∞·ª£c gi·ªØ nguy√™n t·ª´ code c≈© c·ªßa b·∫°n)
//   // =========================================================================
//   useEffect(() => {
//     const fetchAllStations = async () => {
//       try {
//         setIsLoading(true);
//         setError(null);

//         const response = await api.get("/station");

//         const mappedStations = (response.data || [])
//           .map((s) => {
//             // üõë T·ªåA ƒê·ªò: Gi·ªØ nguy√™n logic lat/lng c·ªßa b·∫°n
//             let lat = parseFloat(s.latitude);
//             let lng = parseFloat(s.longitude);

//             if (
//               isNaN(lat) ||
//               isNaN(lng) ||
//               lat < 8 ||
//               lat > 24 ||
//               lng < 102 ||
//               lng > 110
//             ) {
//               console.warn(
//                 `Tr·∫°m "${s.name}" b·ªã b·ªè qua: T·ªça ƒë·ªô ngo√†i ph·∫°m vi VN ho·∫∑c kh√¥ng h·ª£p l·ªá.`
//               );
//               return null;
//             }

//             lat = parseFloat(lat.toFixed(6));
//             lng = parseFloat(lng.toFixed(6));

//             return {
//               ...s,
//               lat,
//               lng,
//               id: s.id || s.name,
//               name: s.name.replace(/Station \d+ - /, "").trim(),
//               status: s.status || "Active",
//               capacity: s.capacity || 80,
//               location: s.address || `Lat: ${lat}, Lng: ${lng}`,
//             };
//           })
//           .filter((s) => s !== null);

//         setStations(mappedStations);
//       } catch (err) {
//         console.error("L·ªói khi t·∫£i d·ªØ li·ªáu c√°c tr·∫°m:", err);
//         setError(err.message || "Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn API.");
//         setStations([]);
//       } finally {
//         setIsLoading(false);
//       }
//     };

//     fetchAllStations();
//     getUserLocation();
//   }, []);

//   // =========================================================================
//   // H√ÄM G·ªåI API ORS
//   // =========================================================================
//   const fetchRouteORS = async ({ start, end }) => {
//     const startLngLat = `${start.lng},${start.lat}`;
//     const endLngLat = `${end.lng},${end.lat}`;

//     const url = `https://api.openrouteservice.org/v2/directions/driving-car?start=${startLngLat}&end=${endLngLat}`;

//     try {
//       const res = await fetch(url, {
//         method: "GET",
//         headers: {
//           Accept: "application/json, application/geo+json",
//           Authorization: ORS_API_KEY,
//           "Content-Type": "application/json",
//           // Th√™m headers n√†y ƒë·ªÉ kh·∫Øc ph·ª•c l·ªói CORS n·∫øu c·∫ßn thi·∫øt
//           Origin: "http://localhost:5173",
//           Referer: "http://localhost:5173/",
//         },
//       });

//       if (!res.ok) {
//         const errorText = await res.text();
//         throw new Error(
//           `Routing failed with status ${res.status}: ${errorText.substring(
//             0,
//             100
//           )}`
//         );
//       }

//       const data = await res.json();
//       const feature = data.features?.[0];
//       const geometry = feature?.geometry;
//       const summary = feature?.properties?.summary;

//       if (!geometry || !summary) {
//         throw new Error("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu ƒë∆∞·ªùng ƒëi.");
//       }

//       return {
//         routeGeo: data, // GI·ªÆ NGUY√äN GeoJSON g·ªëc [lng, lat]
//         distance: summary.distance,
//         duration: summary.duration,
//       };
//     } catch (error) {
//       throw new Error(`L·ªói g·ªçi API ORS: ${error.message}`);
//     }
//   };

//   // H√†m g·ªçi routing ch√≠nh
//   const buildRoute = async (startPoint, endStation) => {
//     // helper: ensure object has {lat,lng}
//     const normalize = (p) => {
//       if (!p) return null;
//       if (p.lat != null && p.lng != null) return { lat: p.lat, lng: p.lng };
//       if (p.latitude != null && p.longitude != null)
//         return { lat: p.latitude, lng: p.longitude };
//       return null;
//     };

//     const start = normalize(startPoint);
//     if (!start) {
//       throw new Error("Invalid start point for routing");
//     }

//     setRouteInfo(null);
//     setRouteGeoJSON(null);
//     setRouteError(null);

//     if (!endStation) return;
//     if (ORS_API_KEY === "YOUR_ORS_KEY_HERE" || !ORS_API_KEY) {
//       setRouteError(
//         "Vui l√≤ng thay th·∫ø ORS_API_KEY b·∫±ng Key OpenRouteService c·ªßa b·∫°n."
//       );
//       return;
//     }

//     setRouteLoading(true);
//     try {
//       const result = await fetchRouteORS({
//         start: start,
//         end: { lat: endStation.lat, lng: endStation.lng },
//       });

//       if (result && result.routeGeo) {
//         setRouteGeoJSON(result.routeGeo);
//         setRouteInfo({
//           distance: formatDistance(result.distance),
//           duration: formatDuration(result.duration),
//         });

//         // C·∫≠p nh·∫≠t view ƒë·ªÉ bao qu√°t tuy·∫øn ƒë∆∞·ªùng
//         const routeCoords = result.routeGeo.features[0].geometry.coordinates;
//         if (routeCoords.length > 0) {
//           const middleIndex = Math.floor(routeCoords.length / 2);
//           const [lng, lat] = routeCoords[middleIndex];
//           setViewState((prev) => ({
//             ...prev,
//             longitude: lng,
//             latitude: lat,
//             zoom: 12,
//             transitionDuration: 1000,
//           }));
//         }
//       } else {
//         setRouteError(`Kh√¥ng t√¨m th·∫•y tuy·∫øn ƒë∆∞·ªùng kh·∫£ d·ª•ng t·ª´ ORS.`);
//       }
//     } catch (error) {
//       console.error("L·ªói khi t√¨m ƒë∆∞·ªùng:", error.message);
//       setRouteError(`L·ªói API t√¨m ƒë∆∞·ªùng: ${error.message}`);
//     } finally {
//       setRouteLoading(false);
//     }
//   };

//   // X·ª≠ l√Ω khi nh·∫•n n√∫t T√¨m ƒë∆∞·ªùng (Ho·∫∑c khi ch·ªçn tr·∫°m)
//   const handleFindRoute = () => {
//     const parsedOrigin = parseCoordinate(originText);
//     let startPoint = userLocation;

//     if (originText.trim() === "") {
//       startPoint = userLocation;
//     } else if (parsedOrigin) {
//       startPoint = parsedOrigin;
//     } else {
//       setRouteError("Vui l√≤ng nh·∫≠p T·ªça ƒë·ªô h·ª£p l·ªá (lat, lng).");
//       setRouteGeoJSON(null);
//       setRouteInfo(null);
//       return;
//     }
//     // Normalize startPoint to { lat, lng } shape so downstream code (Marker, ORS) won't get undefined
//     let normalizedStart = null;
//     if (!startPoint) {
//       normalizedStart = null;
//     } else if (startPoint.lat != null && startPoint.lng != null) {
//       normalizedStart = { lat: startPoint.lat, lng: startPoint.lng };
//     } else if (startPoint.latitude != null && startPoint.longitude != null) {
//       normalizedStart = { lat: startPoint.latitude, lng: startPoint.longitude };
//     } else {
//       // fallback: try to parse if it's a string
//       try {
//         const parsed = parseCoordinate(String(startPoint));
//         normalizedStart = parsed;
//       } catch {
//         normalizedStart = null;
//       }
//     }

//     setCurrentOrigin(normalizedStart);
//     if (currentStation && normalizedStart) {
//       buildRoute(normalizedStart, currentStation);
//     }
//   };

//   // üéØ useEffect T·ª∞ ƒê·ªòNG G·ªåI T√åM ƒê∆Ø·ªúNG
//   useEffect(() => {
//     if (selectedStationName && currentStation) {
//       handleFindRoute();
//     } else {
//       setRouteGeoJSON(null);
//       setRouteInfo(null);
//       setRouteError(null);
//       setPopupInfo(null);
//       // Reset center v·ªÅ FPT
//       console.log(userLocation);
//       // prefer normalized lat/lng (lat,lng) but fallback to latitude/longitude
//       setViewState((prev) => ({
//         ...prev,
//         longitude:
//           userLocation?.lng ?? userLocation?.longitude ?? prev.longitude,
//         latitude: userLocation?.lat ?? userLocation?.latitude ?? prev.latitude,
//         zoom: 12,
//         transitionDuration: 500,
//       }));
//     }
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [selectedStationName, stations]); // Ch·ªâ ch·∫°y khi ch·ªçn tr·∫°m ho·∫∑c khi stations ƒë∆∞·ª£c load

//   // =========================================================================
//   // UI RENDER
//   // =========================================================================
//   if (isLoading) {
//     return (
//       <div style={{ padding: "20px", textAlign: "center" }}>
//         <p>ƒêang t·∫£i d·ªØ li·ªáu tr·∫°m...</p>
//       </div>
//     );
//   }
//   if (error) {
//     return (
//       <div
//         style={{
//           padding: "20px",
//           textAlign: "center",
//           color: "#dc2626",
//           border: "1px solid #fee2e2",
//           borderRadius: "8px",
//           background: "#fef2f2",
//         }}
//       >
//         <p>L·ªói t·∫£i d·ªØ li·ªáu tr·∫°m: {error}</p>
//       </div>
//     );
//   }

//   return (
//     <div>
//       <NavBar />
//       <main style={{ maxWidth: 1200, margin: "24px auto", padding: "0 20px" }}>
//         <header style={{ textAlign: "center", marginBottom: 16 }}>
//           <h1 style={{ fontSize: 28, fontWeight: 700, marginBottom: 8 }}>
//             M·∫°ng l∆∞·ªõi ƒë·ªïi Pin
//           </h1>
//           <div style={{ fontSize: 36, fontWeight: 800, color: "#1e3a8a" }}>
//             {stations.length}
//           </div>
//           <p style={{ color: "#64748b" }}>v√† ƒëang ph√°t tri·ªÉn nhanh.</p>
//         </header>

//         {/* NEAREST STATION */}
//         <div style={{ marginBottom: 12 }}>
//           <NearestStation
//             stations={stations}
//             origin={
//               currentOrigin ||
//               (userLocation
//                 ? {
//                     lat: userLocation.lat ?? userLocation.latitude,
//                     lng: userLocation.lng ?? userLocation.longitude,
//                   }
//                 : null)
//             }
//             onFocus={(station) => {
//               if (!station) return;
//               setSelectedStationName(station.name);
//               setPopupInfo(station);
//               setViewState((prev) => ({
//                 ...prev,
//                 latitude: station.lat,
//                 longitude: station.lng,
//                 zoom: 14,
//                 transitionDuration: 800,
//               }));
//             }}
//           />
//         </div>

//         {/* KHU V·ª∞C T√åM ƒê∆Ø·ªúNG */}
//         <div
//           style={{
//             marginBottom: 12,
//             border: "1px solid #e2e8f0",
//             borderRadius: 8,
//             padding: 16,
//             background: "#f8fafc",
//           }}
//         >
//           <h3
//             style={{
//               marginBottom: 10,
//               fontSize: 18,
//               fontWeight: 600,
//               color: "#1e3a8a",
//             }}
//           >
//             T√¨m ƒë∆∞·ªùng ƒë·∫øn Tr·∫°m
//           </h3>

//           <div style={{ display: "flex", gap: 12 }}>
//             <select
//               style={{
//                 padding: "10px 12px",
//                 border: "1px solid #e2e8f0",
//                 borderRadius: 8,
//                 flex: 1,
//                 background: "#fff",
//               }}
//               value={selectedStationName}
//               onChange={(e) => setSelectedStationName(e.target.value)}
//               disabled={isLoading || error}
//             >
//               <option value="">
//                 {isLoading ? "ƒêang t·∫£i tr·∫°m..." : "Ch·ªçn Tr·∫°m ƒê√≠ch"}
//               </option>
//               {stations.map((s) => (
//                 <option key={s.id} value={s.name}>
//                   {s.name} - ({s.capacity} pin)
//                 </option>
//               ))}
//             </select>
//           </div>
//         </div>

//         {/* HI·ªÇN TH·ªä TH√îNG TIN ƒê∆Ø·ªúNG ƒêI */}
//         {routeLoading && selectedStationName && (
//           <div
//             style={{
//               textAlign: "center",
//               padding: "10px",
//               color: "#4f46e5",
//               fontWeight: 500,
//             }}
//           >
//             ƒêang t√¨m ƒë∆∞·ªùng ƒëi t·ª´{" "}
//             {originText && parseCoordinate(originText) ? originText : "FPT"} ƒë·∫øn{" "}
//             {selectedStationName}...
//           </div>
//         )}
//         {routeInfo && !routeLoading && (
//           <div
//             style={{
//               padding: "10px",
//               marginBottom: "12px",
//               background: "#eef2ff",
//               border: "1px solid #c7d2fe",
//               borderRadius: "8px",
//               display: "flex",
//               justifyContent: "space-between",
//               alignItems: "center",
//             }}
//           >
//             <p style={{ fontSize: "14px", fontWeight: 500, color: "#4f46e5" }}>
//               ƒê∆∞·ªùng ƒëi ƒë·∫øn {selectedStationName}
//             </p>
//             <p style={{ fontSize: "18px", fontWeight: 700, color: "#3730a3" }}>
//               {routeInfo.distance} ({routeInfo.duration})
//             </p>
//           </div>
//         )}
//         {routeError && selectedStationName && !routeLoading && (
//           <div
//             style={{
//               textAlign: "center",
//               padding: "10px",
//               color: "#dc2626",
//               fontWeight: 500,
//               background: "#fee2e2",
//               borderRadius: "8px",
//               marginBottom: "12px",
//             }}
//           >
//             {routeError}
//           </div>
//         )}

//         <div>
//           <Map
//             {...viewState}
//             onMove={(evt) => setViewState(evt.viewState)}
//             style={containerStyle}
//             mapStyle={MAPTILER_STYLE_URL}
//           >
//             {/* 1. Marker cho ƒëi·ªÉm xu·∫•t ph√°t (Start Point) */}
//             {currentOrigin &&
//               typeof currentOrigin.lng === "number" &&
//               typeof currentOrigin.lat === "number" && (
//                 <Marker
//                   longitude={currentOrigin.lng}
//                   latitude={currentOrigin.lat}
//                   anchor="bottom"
//                 >
//                   {/* User location marker - red like Google Maps */}
//                   <PinMarker color="#ef4444" isOrigin={true} />
//                 </Marker>
//               )}

//             {/* 2. Marker cho c√°c Tr·∫°m Pin */}
//             {stations.map((s) => (
//               <Marker
//                 key={s.id}
//                 longitude={s.lng}
//                 latitude={s.lat}
//                 anchor="bottom"
//                 onClick={(e) => {
//                   e.originalEvent.stopPropagation();
//                   setPopupInfo(s);
//                 }}
//               >
//                 <PinMarker
//                   color={selectedStationName === s.name ? "#ef4444" : "#10b981"} // ƒê·ªè khi ƒë∆∞·ª£c ch·ªçn
//                   capacity={s.capacity}
//                   isOrigin={false}
//                 />
//               </Marker>
//             ))}

//             {/* üõë POPUP HI·ªÇN TH·ªä TH√îNG TIN TR·∫†M S·∫†C */}
//             {popupInfo && (
//               <Popup
//                 longitude={popupInfo.lng}
//                 latitude={popupInfo.lat}
//                 closeButton={true}
//                 closeOnClick={false}
//                 onClose={() => setPopupInfo(null)}
//                 anchor="bottom"
//               >
//                 <div style={{ minWidth: 180, padding: 5 }}>
//                   <h4
//                     style={{
//                       fontSize: 16,
//                       fontWeight: 700,
//                       margin: "0 0 5px 0",
//                       color: "#1e3a8a",
//                     }}
//                   >
//                     {popupInfo.name}
//                   </h4>
//                   <p
//                     style={{ margin: "0 0 2px 0", fontSize: 13, color: "#444" }}
//                   >
//                     V·ªã tr√≠: **{popupInfo.location}**
//                   </p>
//                   <p
//                     style={{
//                       margin: "0 0 5px 0",
//                       fontSize: 13,
//                       fontWeight: 600,
//                       color: "#10b981",
//                     }}
//                   >
//                     Dung l∆∞·ª£ng: **{popupInfo.capacity}** pin
//                   </p>
//                   <button
//                     onClick={() => {
//                       setSelectedStationName(popupInfo.name);
//                       setPopupInfo(null);
//                       // Ch·ª©c nƒÉng t√¨m ƒë∆∞·ªùng s·∫Ω t·ª± ƒë·ªông ch·∫°y trong useEffect khi selectedStationName thay ƒë·ªïi
//                     }}
//                     style={{
//                       padding: "5px 10px",
//                       background: "#2563eb",
//                       color: "white",
//                       border: "none",
//                       borderRadius: 4,
//                       fontSize: 12,
//                       cursor: "pointer",
//                     }}
//                   >
//                     Ch·ªçn l√†m Tr·∫°m ƒê√≠ch
//                   </button>
//                 </div>
//               </Popup>
//             )}

//             {/* 3. L·ªõp hi·ªÉn th·ªã ƒê∆∞·ªùng ƒëi (Route) */}
//             {routeGeoJSON && (
//               <Source id="route-data" type="geojson" data={routeGeoJSON}>
//                 <Layer {...polylineLayerStyle} />
//               </Source>
//             )}
//           </Map>
//         </div>
//       </main>
//     </div>
//   );
// }

// export default StationsNearbyPage;
// src/components/RouteFinderVN.jsx
// src/components/RouteFinderORS.jsx
import React, { Fragment, useEffect, useState, useRef } from "react";
import { MapContainer, TileLayer, Marker, Popup, useMap } from "react-leaflet";
import { Select, Card, Spin } from "antd";
import api from "../../config/axios";
import L from "leaflet";
import "leaflet/dist/leaflet.css";
import Navbar from "../../components/navbar/navBar";

const { Option } = Select;

// Custom Marker icon (Leaflet kh√¥ng load m·∫∑c ƒë·ªãnh)
delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl:"https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon-2x.png",
  iconUrl: "https://cdn-icons-png.flaticon.com/512/854/854866.png",
  iconSize: [32, 32],
  shadowUrl: "https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png",
});

// Component ƒë·ªÉ focus map t·ªõi v·ªã tr√≠ m·ªõi
function FlyToLocation({ position }) {
  const map = useMap();
  useEffect(() => {
    if (position) map.flyTo(position, 13, { duration: 1.5 });
  }, [position]);
  return null;
}

const StationsNearby = () => {
  const [stations, setStations] = useState([]);
  const [loading, setLoading] = useState(true);
  const [selectedCity, setSelectedCity] = useState(null);
  const [selectedDistrict, setSelectedDistrict] = useState(null);
  const [selectedStation, setSelectedStation] = useState(null);
  const markerRefs = useRef({});

  // G·ªçi API l·∫•y d·ªØ li·ªáu tr·∫°m
  useEffect(() => {
    const fetchStations = async () => {
      try {
        const res = await api.get("/station");
        setStations(res.data);
      } catch (err) {
        console.error("L·ªói khi t·∫£i tr·∫°m:", err);
      } finally {
        setLoading(false);
      }
    };
    fetchStations();
  }, []);

  // Gom nh√≥m theo th√†nh ph·ªë ‚Üí qu·∫≠n
  const cities = [...new Set(stations.map((s) => s.city))];
  const districts = selectedCity
    ? [
        ...new Set(
          stations.filter((s) => s.city === selectedCity).map((s) => s.district)
        ),
      ]
    : [];

  // L·ªçc c√°c tr·∫°m hi·ªÉn th·ªã
  const filteredStations = stations.filter(
    (s) =>
      (!selectedCity || s.city === selectedCity) &&
      (!selectedDistrict || s.district === selectedDistrict)
  );

  if (loading) return <Spin tip="ƒêang t·∫£i d·ªØ li·ªáu tr·∫°m..." />;
  const handleStationClick = (station) => {
    setSelectedStation(station);

    // ƒê·ª£i m·ªôt ch√∫t cho map flyTo xong, sau ƒë√≥ m·ªü popup
    setTimeout(() => {
      const ref = markerRefs.current[station.id];
      if (ref) ref.openPopup();
    }, 800);
  };

  return (
    <Fragment>
      <Navbar />
      <div style={{ display: "flex", height: "90vh", gap: "1rem" }}>
        {/* Sidebar b·ªô l·ªçc */}
        <Card title={<div style={{ fontSize: '24px', fontWeight: "bold", color: '#1890ff', textAlign: 'center', marginTop: '16px' }}> <h1>H·ªá th·ªëng tr·∫°m</h1>

        </div>} style={{ width: 300 }}>
          <p>
            <strong>Th√†nh ph·ªë:</strong>
          </p>
          <Select
            style={{ width: "100%", marginBottom: 10 }}
            placeholder="Ch·ªçn th√†nh ph·ªë"
            allowClear
            onChange={(v) => {
              setSelectedCity(v);
              setSelectedDistrict(null);
            }}
          >
            {cities.map((city) => (
              <Option key={city} value={city}>
                {city}
              </Option>
            ))}
          </Select>

          <p>
            <strong>Qu·∫≠n / Huy·ªán:</strong>
          </p>
          <Select
            style={{ width: "100%" }}
            placeholder="Ch·ªçn qu·∫≠n / huy·ªán"
            allowClear
            value={selectedDistrict}
            onChange={setSelectedDistrict}
            disabled={!selectedCity}
          >
            {districts.map((d) => (
              <Option key={d} value={d}>
                {d}
              </Option>
            ))}
          </Select>

          <p style={{ marginTop: 16 }}>
            <strong>Tr·∫°m hi·ªán c√≥:</strong>
          </p>
          <ul style={{ maxHeight: 300, overflowY: "auto", paddingLeft: 16 }}>
            {filteredStations.map((s) => (
              <li
                key={s.id}
                onClick={() => handleStationClick(s)}
                style={{
                  cursor: "pointer",
                  marginBottom: 8,
                  color: "#1890ff",
                }}
              >
                üìç {s.name} ({s.district})
              </li>
            ))}
          </ul>
        </Card>

        {/* Map */}
        <MapContainer
          center={[10.762622, 106.660172]}
          zoom={12}
          style={{ flex: 1 }}
        >
          <TileLayer
            attribution='&copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a>'
            url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
          />

          {selectedStation && (
            <FlyToLocation
              position={[selectedStation.latitude, selectedStation.longitude]}
            />
          )}

          {filteredStations.map((s) => (
            <Marker
              key={s.id}
              position={[s.latitude, s.longitude]}
              ref={(ref) => (markerRefs.current[s.id] = ref)} // ‚úÖ L∆∞u ref cho t·ª´ng marker
            >
              <Popup>
                <strong>{s.name}</strong> <br />
                üìç {s.location} <br />
                ‚òéÔ∏è {s.contactInfo} <br />‚ö° Pin hi·ªán c√≥: {s.currentBatteryCount}{" "}
                / {s.capacity}
              </Popup>
            </Marker>
          ))}
        </MapContainer>
      </div>
    </Fragment>
  );
};

export default StationsNearby;
